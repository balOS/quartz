<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Neural Databases URL - https://arxiv.org/pdf/2010.06973v1.pdf
Core Questions [[Q- Can neural networks answer queries from natural language without a predefined schema]]? [[Q- What would a discourse graph without a predefined schema look like]]?"><title>R- Neural Databases</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://scalingsynthesis.com//icon.png><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Fira+Code:wght@400;700&display=swap" rel=stylesheet><link href=https://scalingsynthesis.com/styles.b87d33b33b175b9bcd6682f2f1b94b59.min.css rel=stylesheet><script src=https://scalingsynthesis.com/js/darkmode.46b07878b7f5d9e26ad7a3c40f8a0605.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://scalingsynthesis.com/js/popover.b09d478d74c2f86dcb7758afddc318bf.min.js></script>
<script>const BASE_URL="https://scalingsynthesis.com/",fetchData=Promise.all([fetch("https://scalingsynthesis.com/indices/linkIndex.f9980e5a340da2dd6eabfbe865ff92d9.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://scalingsynthesis.com/indices/contentIndex.2985a94860e4788dddefb11934fc790b.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n}))</script><script type=module>
    import { attachSPARouting } from 'https:\/\/scalingsynthesis.com\/js\/router.88d6def7f687fe498bfc6de6c16d554b.min.js';
    
    const draw = () => {
      const container = document.getElementById("graph-container")
      
      if (!container) return requestAnimationFrame(draw)
      
      container.textContent = ""

      drawGraph(
        "https://scalingsynthesis.com",
        [{"/moc":"#4388cc"}],
         0 ,
         true ,
         false ,
         true 
      );

      
      initPopover("https://scalingsynthesis.com",  true )
      
      
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
        throwOnError : false
      });
      
    };
    attachSPARouting(draw);
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-5P7KT5C8ET"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5P7KT5C8ET",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://scalingsynthesis.com/js/search.7c24ccf709dbc2daa3900b46c3269409.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://scalingsynthesis.com/>🪴 Discourse Graph Research</a></h1><svg tabindex="0" id="search-icon" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><div class=spacer></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>R- Neural Databases</h1><p class=meta>Last updated May 2, 2022</p><ul class=tags></ul><a href=#neural-databases><h3 id=neural-databases><span class=hanchor arialabel=Anchor># </span>Neural Databases</h3></a><p>URL -
<a href=https://arxiv.org/pdf/2010.06973v1.pdf rel=noopener>https://arxiv.org/pdf/2010.06973v1.pdf</a></p><a href=#core-questions><h4 id=core-questions><span class=hanchor arialabel=Anchor># </span>Core Questions</h4></a><p><a class="internal-link broken">Q- Can neural networks answer queries from natural language without a predefined schema</a>?
<a class="internal-link broken">Q- What would a discourse graph without a predefined schema look like</a>?</p><p>related questions from Rob
<a class="internal-link broken">Rob/Q- What is the data structure of a graph built to facilitate decentralized knowledge synthesis</a>
<a class="internal-link broken">Q- How might you allow people to query information without explicit knowledge of how that information is structured</a>
<a class="internal-link broken">Q- How do people come to agree on queryable schemas</a>
<a class="internal-link broken">Rob/Q- How do we solve the problem of different people referring to the same concept with different language</a></p><p>related reading
<a class="internal-link broken">R- Polysemy and thought - Toward a generative theory of concepts</a></p><p>What if there doesn&rsquo;t need to be a database schema?</p><blockquote><p>We describe NeuralDB, a database system with no pre-defined schema, in which updates and queries are given in natural language. We develop query processing techniques that build on the primitives offered by the state of the art Natural Language Processing methods.
We begin by demonstrating that at the core, recent NLP transformers, powered by pre-trained language models, can answer select-project-join queries if they are given the exact set of relevant facts. However, they cannot scale to non-trivial databases and cannot perform aggregation queries.
Based on these findings, we describe a NeuralDB architecture that runs multiple Neural SPJ operators in parallel, each with a set of database sentences that can produce one of the answers to the query. The result of these operators is fed to an aggregation operator if needed.
We describe an algorithm that learns how to create the appropriate sets of facts to be fed into each of the Neural SPJ operators. Importantly, this algorithm can be trained by the Neural SPJ operator itself.
In applying neural nets to data management, research has so far assumed that the data was modeled by a database schema
What if, instead, data and queries can be represented as short natural language sentences, and queries can be answered from these sentences?
The query processor of a NeuralDB builds on the primitives that are offered by the state of the art Natural Language Processing (NLP) techniques.
Our experimental results suggest that it is possible to attain very high accuracy for a class of queries that involve select, project, join possibly followed by an aggregation.</p></blockquote><p>NeuralDB has no predefined schema, can be queried in natural language, is backed by NLP, and can extend to more domain knowledge with training.</p><blockquote><p>The first, and most important benefit is that a NeuralDB, by definition, has no pre-defined schema. Therefore, the scope of the database does not need to be defined in advance and any data that becomes relevant as the application is used can be stored and queried.
The second benefit is that updates and queries can be posed in a variety of natural language forms, as is convenient to any user. In contrast, a traditional database query needs to be based on the database schema.
A third benefit comes from the fact that the NeuralDB is based on a pre-trained language model that already contains a lot of knowledge.
Furthermore, using the same paradigm, we can endow the NeuralDB with more domain knowledge by extending the pre-training corpus to that domain.</p></blockquote><blockquote><p>The main goal of NeuralDB is to support data management applications where users do not need to pre-define a schema. Instead, they can express the facts in the database in any linguistic form they want, and queries can be posed in natural language. To that end, data and queries in a NeuralDB are represented as short sentences in natural language and the neural machinery of the NeuralDB is applied to these sentences.</p></blockquote><p>Q- What are neural databases good for?</p><blockquote><p>Given its benefits, Neural Databases are well suited for emerging applications where the schema of the data cannot be determined in advance and data can be stated in a wide range of linguistic patterns. A family of such applications arise in the area of storing knowledge for personal assistants that currently available for home use and in the future will accompany Augmented Reality glasses. In these applications, users store data about their habits and experiences, their friends and their preferences, and designing a schema for such an application is impractical. Another class of applications is the modeling and querying of political claims [46] (with the goal of verifying their correctness). Here too, claims can be about a huge variety of topics and expressed in many ways.
Our first contribution is to show that state of the art transformer models [47] can be adapted to answer simple natural language queries. Specifically, the models can process facts that are relevant to a query independent of their specific linguistic form, and combine multiple facts to yield correct answers, effectively performing a join.
Our second contribution is to propose an architecture for neural databases that uses the power of transformers at its core, but puts in place several other components in order to address the scalability and aggregation issues. Our architecture runs multiple instances of a Neural SPJ operator in parallel. The results of the operator are either the answer to the query or the input to an aggregation operator, which is done in a traditional fashion. Underlying this architecture is a novel algorithm for generating the small sets of database sentences that are fed to each Neural SPJ operator
Finally, we describe an experimental study that validates the different components of NeuralDBs, namely the ability of the Neural SPJ to answer queries or create results for a subsequent aggregation operator even with minimal supervision, and our ability to produce support sets that are fed into each of the Neural SPJ operators. Putting all the components together, our final result shows that we can accurately answer queries over thousands of sentences with very high accuracy. To run the experiments we had to create an experimental dataset with training data for NeuralDBs, which we make available for future research.</p></blockquote><p>Q- What are neural databases bad at?
Q- How large of a dataset could be used with a neural database?</p><blockquote><p>However, we identify two major limitations of these models: (1) they do not perform well on aggregation queries (e.g., counting, max/min), and (2) since the input size to the transformer is bounded and the complexity of the transformer is quadratic in the size of its input, they only work on a relatively small collection of facts.
We also assume that pronouns (e.g., she, they) are not used or have been resolved in advance. The application of the rich body of work on entity resolution to NeuralDBs will be reserved for future work.</p></blockquote><p>More research is needed:</p><blockquote><p>To fully realize the promise of NeuralDBs, more research is needed on scaling up NeuralDBs to larger databases, supporting more complex queries and increasing the accuracy of the answers. In particular, an interesting area of research noted in Section 5 is developing novel indexing techniques that enable efficient support set generation.
Another exciting area to investigate is to consider other media in the database. For example, a database can also contain a set of images and some queries can involve combining information from language and from images. Such an extension would benefit from recent progress on visual query answering systems [3, 5].
Finally, another interesting challenge concerns developing semantic knowledge that helps in identifying which updates should replace previous facts and which should not.</p></blockquote><p>What challenges arise with databases that NeuralDB solves?</p><blockquote><p>However, the following additional challenges arise in the context of NeuralDBs:
> • Unlike open-book QA, which typically requires extracting a span from a single document or predicting a token as an answer, answering queries in a NeuralDB may require processing a large number of facts and in some cases performing aggregations over large sets.
> • NeuralDBs do not enjoy the locality properties that usually hold in open-book QA. In NeuralDBs, a query may be dependent on multiple facts that can be anywhere in the database. In fact, by definition, the current facts in a database can be reordered and the query answers should not change. In contrast, in open-book QA, the fact needed to answer a given question is typically located in a paragraph or document with multiple sentences about the same subject where this additional context may help information recall.
> • When determining which facts to input to the transformer, NeuralDBs may require conditional retrieval from the database. For example, to answer the query Whose spouse is a doctor? we’d first need to fetch spouses and then their professions. In the NLP community this is known as multihop query answering [6], which has recently become an active area of research, but restricted to the case where we’re looking for a single answer. In NeuralDBs, we may need to perform multi-hops for sets of facts.
> A possible downside of using neural techniques in a database system is the potential for bias that might be encoded in the underlying language model.
> A possible approach to this important issue is to design a separate module that attacks the database with queries in order to discover hidden biases. Then, we could devise safeguards within the database that ensure that we don’t use such biased knowledge in answering queries. Developing these components is an area for future research.</p></blockquote><p>Methodology</p><blockquote><p>The Transformer model [47] is the most common neural architecture to operate on pre-trained language models based on the high accuracy it produces on downstream tasks including question answering on text. In our prototype experiments, detailed in Section 3, we demonstrate that these reasoning abilities enable the transformer architecture to generate correct answers to a number of queries that we might pose to a NeuralDB.
Evaluating accuracy of answers. We measure the correctness of the answers generated by a NeuralDB by comparing them against reference data that contain the correct answers. The neural networks are trained with subset of the available data, leaving a portion of it held-out for evaluation, referred to as the test set.
For most queries, we measure correctness using Exact Match (EM), which is 1 if a binary the answer string generated by the NeuralDB is exactly equal to the reference answer and 0 otherwise. This metric is used to score outputs where either a Boolean, null answer, string or numeric answer is expected.
When a set of results is returned, we also consider the 𝐹1 score that weighs the precision and recall of the answer generated by the NeuralDB as compared to the reference data
They are typically trained in one of two configurations: encoder only or encoder-decoder. In the former, each token is encoded to a vector representation that is used to predict a label. In the latter, used in sequence-to-sequence applications (e.g., question answering or machine translation), the decoder produces the output sequence.
In both configurations, the transformer works in two phases. In the first phase, the transformer encodes the input into an intermediate representation z = (𝑧1, . . . , 𝑧𝑛) where the dimension of the vector is fixed, typically where 𝑑𝑚𝑜𝑑𝑒𝑙 = 768. In the second phase, the transformer decodes z to produce the output. For example, in sequence-to-sequence generation the output would be a sequence of tokens y = (𝑦1, . . . , 𝑦𝑙 ), ending with a special token.
We generate training data in a controlled fashion using data from Wikidata [48] to express facts in natural language. Because of the scale of Wikidata, it is possible to generate large numbers of training instances about a wide range of relationships requiring very few templates.
We believe that the initial experiment suggests the following: (1) if there were a way to feed the transformer the relevant facts from the database, it can produce results with reasonable accuracy, (2) aggregation queries need to be performed outside of the neural machinery, and (3) in order to handle queries that result in sets of answers and in order to prepare sets for subsequent aggregation operators, we need to develop a neural operator that can process individual (or small sets of) facts in isolation and whose results outputted as the answer or fed into a traditional (i.e. nonneural) aggregation operator.</p></blockquote><p>Related Work</p><blockquote><p>NLP and data management. Bridging the gap between unstructured natural language data and database-style querying has been a longstanding theme in database research [15]. The work on information extraction has developed techniques for translating segments of natural language text into triples that can be further processed by a database system. Wikidata [48] itself is a social experiment where additions to the knowledge graph are encouraged to use already existing relation names if possible, thereby alleviating the need for information extraction. There has been significant work on translating queries posed in natural language into SQL queries on a database whose schema is known [4, 23, 58], with extensions to semi-structured data and knowledge bases [7, 30]. More recently, systems such as BREAK [57] and ShARC [41] have trained models to translate a natural language query into a sequence of relational operators (or variants thereof).
While other works modeling the web as a knowledge bases have focused on combining multiple snippets of text together [44], their assumption is that the query is decomposed into a SPARQL program that is executed on pre-extracted information. Our innovation is that no latent program or structure is needed and that information extraction is dynamic and dependent on the query.</p></blockquote></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/I-A-DSL-for-a-discourse-graph-with-information-entry-visualization-and-retrieval/ data-ctx="R- Neural Databases" data-src=/I-A-DSL-for-a-discourse-graph-with-information-entry-visualization-and-retrieval class=internal-link>I- A DSL for a discourse graph with information entry, visualization, and retrieval</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://scalingsynthesis.com/js/graph.b1918b922eeaaafa9b380261436bf451.js></script></div></div><div id=contact_buttons><footer><p>Made by Rob Haisfield, Joel Chan, Brendan Langen using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2022</p><ul><li><a href=/>Home</a></li><li><a href=https://twitter.com/RobertHaisfield>Twitter</a></li><li><a href=https://github.com/balOS>Github</a></li></ul></footer></div></div></body></html>