<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="[[C- A structural editor can make a DSL approachable to end-users]] [[structural editor]]
Prune: A Code Editor that is Not a Text Editor"><title>R- Prune Structural Editor</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://scalingsynthesis.com//icon.png><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Fira+Code:wght@400;700&display=swap" rel=stylesheet><link href=https://scalingsynthesis.com/styles.38e830a043f5b6ac6b132f012fca1f33.min.css rel=stylesheet><script src=https://scalingsynthesis.com/js/darkmode.46b07878b7f5d9e26ad7a3c40f8a0605.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://scalingsynthesis.com/js/popover.288199e63b3f94c382ad0a682c368d9d.min.js></script>
<script>const BASE_URL="https://scalingsynthesis.com/",fetchData=Promise.all([fetch("https://scalingsynthesis.com/indices/linkIndex.5965e276520a5fafd7f53bbda09680fc.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://scalingsynthesis.com/indices/contentIndex.8aa353ef763c7fa402b4aa097cae11f7.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),draw=()=>{initPopover("https://scalingsynthesis.com",!0),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.navigate=e=>window.location.href=e,draw()</script><script>window.navigate=e=>window.location.href=e</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-5P7KT5C8ET"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5P7KT5C8ET",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://scalingsynthesis.com/js/search.1b393cefe641096453553b4a9b1c5f30.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://scalingsynthesis.com/>ðŸª´ Scaling Synthesis</a></h1><svg tabindex="0" id="search-icon" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><div class=spacer></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>R- Prune Structural Editor</h1><p class=meta>Last updated February 21, 2023</p><ul class=tags><li><a href=https://scalingsynthesis.com/tags/source/>Source</a></li></ul><p><a href=/C-A-structural-editor-can-make-a-DSL-approachable-to-end-users rel=noopener class=internal-link data-src=/C-A-structural-editor-can-make-a-DSL-approachable-to-end-users>C- A structural editor can make a DSL approachable to end-users</a> <a href=/structural-editor rel=noopener class=internal-link data-src=/structural-editor>structural editor</a></p><p>Prune: A Code Editor that is Not a Text Editor</p><p>Co-authored with
<a target=_blank href=https://www.facebook.com/thiago.hirai rel=noopener>Thiago Hirai</a></p><p>You want to change the tree structure of a program. You figure out what series of text editing operations, operations that manipulate a 2D grid of characters, are equivalent to the change in the tree you desire. What a waste of time and energy.</p><p><img src="https://scontent-lax3-2.xx.fbcdn.net/v/t1.18169-9/11887919_10153576066383675_9029286239017821809_n.jpg?_nc_cat=107&ccb=1-3&_nc_sid=abc084&_nc_ohc=uQCinam2-PUAX-D7YgQ&_nc_ht=scontent-lax3-2.xx&oh=3b4eb7a08948d0f033674f4ccf8acc9b&oe=60D961C1" alt></p><p><em>Programmers waste energy translating tree transformations into character grid transformations</em></p><p>Religious editor wars are a symptom that the whole paradigm of editing programs with a text editor is broken. Text editors for code have been universally used for decades, however.</p><p>Prune lets programmers edit the tree structure directly using commands invoked by typing and rendering the resulting code in a familiar textual format. However, it&rsquo;s time for someone else to pick up the torch of tree-based editing.</p><p><img src="https://scontent-lax3-1.xx.fbcdn.net/v/t1.18169-9/11924259_10153576067688675_6046809493243199041_n.jpg?_nc_cat=110&ccb=1-3&_nc_sid=abc084&_nc_ohc=3owH-HCk58kAX9ULsSF&_nc_ht=scontent-lax3-1.xx&oh=296e8d6ac531295e603b1e09f6b3573c&oe=60D997A3" alt></p><p><em>In Prune, programmers transform the tree directly</em></p><a href=#the-dream><h2 id=the-dream><span class=hanchor arialabel=Anchor># </span><strong>The Dream</strong></h2></a><p>Prune is a code editor that operates directly on the tree structure of the code. While it renders code in a familiar textual format, it doesn&rsquo;t offer text editing operations. Programs are created and edited by creating, deleting, and re-organizing nodes in the program&rsquo;s abstract syntax tree.</p><p>Prune grew out of hundreds of hours of observing programmers editing programs with text editors. Proficient users spent considerable energy learning and optimizing their use of the editor. Unskilled users spent considerable energy using the editor badly. Perhaps the problem is not their skill, but the whole idea of using a text editor, a very general tool, for the specific task of program editing.</p><p>Structure editors have been around for decades, yet they never caught on for mainstream usage. Prune would have to be substantially better to have a chance of being adopted. While our overall goal was to reduce the cognitive load of manipulating programs, &ldquo;cognitive load&rdquo; is hard to measure, so we chose three quantifiable goals:</p><ul><li>Fewer keystrokes</li><li>Fewer errors</li><li>Greater overall efficiency</li></ul><a href=#tree-transformations><h2 id=tree-transformations><span class=hanchor arialabel=Anchor># </span><strong>Tree Transformations</strong></h2></a><p>The fundamental operation in Prune takes one program tree and produces another. For example, making a statement conditional is a single operation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cache = computeValue; ==&gt; if (!cache) {   cache = computeValue; }
</span></span></code></pre></td></tr></table></div></div><p>This transformation is one of a class of &ldquo;wrap&rdquo; transformation&ndash;take the current selection, make it a child of a new node, and replace the selection with the new node. Other &ldquo;wraps&rdquo; are looping over a statement or statements, surrounding statements with an exception handler, and returning the value of an expression. Mirror &ldquo;unwrap&rdquo; transformations replace a parent node with one or more of its children, such as making a statement unconditional only executing it once instead of in a loop. Other transformations create nodes, delete nodes, and reorder nodes.</p><p>The transformations are all atomic, in that they take a syntactically correct program and produce another syntactically correct program. This is one way Prune helps reduce errors&ndash;programs are syntactically correct by construction. The transformations compose&ndash;each takes a tree and a selection and produces a tree and a selection that can act as the input to another transformation. Once we had a basic library of transformations, we found that we could sometimes synthesize new transformations by composition instead of having to write new code to manipulate the tree. The transformations are also reversible, a property lacking in many text editors that have been enhanced to work on code.</p><a href=#i-should-be-able-to-leave-a-hole-to-fill-in-the-blanks-for-an-idea-or-domaintbd-node><h2 id=i-should-be-able-to-leave-a-hole-to-fill-in-the-blanks-for-an-idea-or-domaintbd-node><span class=hanchor arialabel=Anchor># </span><strong><a class="internal-link broken">TBD Node</a></strong></h2></a><p>One serendipitous discovery that deserves special mention is the TBD node, used above. Some transformations require two or more parameters. For example, creating a binary expression requires a left side, a right side, and an operator. In a panic we added a special node to the tree representing code to be filled in later. We found it useful in many situations and it never intruded on our work as users of Prune. It did require us to modify the pretty printer we used (esprima), but it was well worth it.</p><p>One piece of interface philosophy we carried through Prune is that the editor should allow the user to build a tree by introducing nodes in any order. We have so little experience coding through tree transformations that we have no confidence we have found the most efficient sequence (if one exists).</p><a href=#typeahead><h2 id=typeahead><span class=hanchor arialabel=Anchor># </span><strong>Typeahead</strong></h2></a><p>One of the risks we identified at the beginning of the project was the number of distinct transformation. If hundreds or thousands of distinct transformations were required to program effectively no one would want to learn them all.</p><p>It turns out that a hundred or so transformation suffice for editing JavaScript (our source and our target language). Even a hundred transformations is a lot to remember. When we measured our performance editing samples of code, we found selecting transformations and entering identifiers to be a bottleneck.</p><p>To accelerate editing and make Prune feel more familiar, we created a typeahead. When the user begins typing, Prune can guess what tree transformation is implied. For example, typing &ldquo;if&rdquo; implies a conditional, a guess that is confirmed when a space follows. The If transformation is invoked at that point, leaving the typeahead ready for input at the condition.</p><p>With practice, pruning with the typeahead feels a little like just typing. However, all the &ldquo;noise&rdquo; characters, put there just to make the parser happy, like parentheses and curly braces appear automatically. Typeahead adds to the efficiency of editing, reduces keystrokes, and makes Prune more approachable.</p><a href=#the-project><h2 id=the-project><span class=hanchor arialabel=Anchor># </span><strong>The Project</strong></h2></a><p>Prune began as a part-time project, motivated, as mentioned earlier, by watching programmers struggle with text editors. The first prototype was completely simulated on paper, just enough to validate that reducing the keystroke count was possible.</p><p>With that bit of evidence in hand, the authors applied for a Hackamonth. After a year with the same team, Facebook engineers are encouraged to take a month and work on something unrelated. It&rsquo;s considered reasonable to fail attempting an ambitious hack, so off we went. Early in the project we created a Facebook-only group devoted to Prune, which slowly accumulated interested members as we posted the results of experiments, demo videos, and the occasional plea for someone to put us out of our misery.</p><p>After the first month we had a version of Prune that we were able to frequently use to add features to Prune. However, reflection on usage showed that our pure &ldquo;invoke transformations through key bindings&rdquo; wasn&rsquo;t going give us the efficiency we wanted. We applied for a second month to implement and measure the typeahead.</p><p>At the end of the second month the developers and those who were interested in embedding Prune in their tools met to discuss its future. In the end we struck a rock we had identified in our first presentation&ndash;programmers don&rsquo;t spend that much time manipulating programs compared to all the other things they do. Doing the math, enabling a few hundred programmers to do a 50% better job (an ambitious goal) of a task requiring 10% of their time just doesn&rsquo;t make economic sense.</p><p>However, we were surprised by what we learned working on Prune and we hope the ideas live and grow. That&rsquo;s why we are publishing this, in hopes that a graduate student somewhere won&rsquo;t mind a project that takes over his or her life and brings joy to (eventually) millions.</p><a href=#the-lessons><h2 id=the-lessons><span class=hanchor arialabel=Anchor># </span><strong>The Lessons</strong></h2></a><ul><li>Pure tree transformation is a viable option for editing code. The goals of reducing keystrokes and errors are within reach.</li><li>Insisting on a pure tree transformation-based editor accelerated our research. If we had a text editor to fall back on, we wouldn&rsquo;t have thought hard enough about the problems that were eventually solved by the typeahead.</li><li>Dogfooding is a powerful resource allocation heuristic. A complete code editor is a sizeable beast, but implementing what we needed to make the next change to Prune in Prune gave us a series of bite-sized features in a reasonable order. Bad experiences helped us quickly eliminate bad ideas.</li><li>Structure research around questions, not features. We were able to get answers to critical questions about efficiency quickly because we were explicit about what questions we were asking. Working features to completion would have delayed, by months or years, those answers.</li><li>Collaborate. Most Hackamonths are fairly solitary affairs, with an engineer seconded to a host team but running a separate project. We coded together daily in spite of our geographical split, which resulted in faster learning, more energy, and fewer dead-ends.</li><li>We didn&rsquo;t miss formatting. We are both fussy about code formatting, but almost as soon as we were constrained to what the pretty-printer (esprima) gave us, we didn&rsquo;t waste any more thought on it.</li><li>Typing is an effective way of identifying and invoking tree transformations.</li></ul><a href=#future><h2 id=future><span class=hanchor arialabel=Anchor># </span><strong>Future</strong></h2></a><p>One of the curses and blessings of programming at Facebook is there is no shortage of impact work, so both of us reluctantly decided to move on. We still believe in the promise of tree-based editing and would love to use a completed version of Prune. We hope to encourage someone out there to take up the torch. Here are a few tips if it&rsquo;s you:</p><ul><li>Target a tablet first. Going head-to-head with vim and emacs is always going to be tough. Deliver on an input-deprived format like tablets, though, and you increase your chance of success. Prune&rsquo;s sparing use of input may also open up the possibility of voice input or other ways of making programming accessible to programmers who find typing difficult.</li><li>Use a declarative language to define transformations. We defined out transformations imperatively, which was tedious and error prone.</li><li>Use a predictive parser, one that can tell you what characters can legally come next and what tree transformations each character implies. We wrote an ugly, fragile state machine for our typeahead, which quickly became a source of pain and shame.</li><li>Try to use the language-oriented tools from JetBrains. It seems like they have infrastructure that might make Prune an order of magnitude easier to implement.</li><li>Implement macros. Letting programmers compose their own sequences of composable transformations seems like a good way to learn what operations are needed.</li><li>Reuse the transformations. It seems like it should be possible to write a version control system that merges streams of transformations instead of textual diffs, potentially reducing the number of merge conflicts.</li><li>Code tree transformations declaratively. We coded them imperatively and it took much too long.</li><li>To further reduce the input required, consider using machine learning to predict which transformation will come next. Tune it well enough and much of programming could become &ldquo;yep, yep, yep&rdquo;, saving the hard thinking for the hard problems.</li></ul><p>Happy pruning.</p></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div></div><div id=contact_buttons><footer><p>Made by Rob Haisfield, Joel Chan, Brendan Langen using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2023</p><ul><li><a href=/>Home</a></li><li><a href=https://twitter.com/RobertHaisfield>Twitter</a></li><li><a href=https://github.com/classicrob/quartz>Github</a></li></ul></footer></div><script defer src=https://cdn.commento.io/js/commento.js></script><div id=commento></div></div></body></html>